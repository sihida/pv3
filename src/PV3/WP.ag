module {PV3.WP}{}
{
import PV3.Condition.ConditionAST
import PV3.Condition.Replace
import PV3.Program.ProgramAST
}

{
bounded :: Int
bounded = 20
}

include "Program/ProgramAST.ag" 

attr Program Statement Instruction StatementList
  inh wp                  :: Cond
  syn wp                  :: Cond
  
attr Statement Instruction StatementList
  inh wp'                 :: Cond
  syn wp'                 :: Cond

  syn copy                :: self
  
attr Instruction
  syn length              :: Int
    
attr StatementList
  inh length              :: Int
  syn length use {+} {0}  :: Int
  
attr Statement
  inh length              :: Int
  syn length              :: Int
  
attr Literal
  syn copy                :: self
    
sem Program
  | Program  loc.wp'     = CAnd @lhs.wp (CEQ (ITopStackIndex 0) (ILit (-1)))
             body.wp     = @wp'
                 .length = 0
             lhs.wp      = replace (replaceParamWithOld @nParams @body.wp) Nothing (Just (ITopStackIndex 0, ILit (-1)))
  
sem Statement
  | SIfTrueElse  lhs.wp             = CAnd (CGTE (ITopStackIndex 0) (ILit 0))
                                           (COr (CAnd (CStack (ITopStackIndex 0))        (replace @trueBranch.wp  Nothing (Just (ITopStackIndex 0, ITopStackIndex (-1)))))
                                                (CAnd (CNot (CStack (ITopStackIndex 0))) (replace @falseBranch.wp Nothing (Just (ITopStackIndex 0, ITopStackIndex (-1))))))
                 lhs.length         = max @trueBranch.length @falseBranch.length
                 falseBranch.wp     = @lhs.wp
                            .wp'    = @lhs.wp'
                            .length = @lhs.length
                         
  | SWhileTrue   lhs.wp = let w0            = CAnd (CNot (CStack (ITopStackIndex 0))) (wp_Syn_Statement $ wrap_Statement (sem_Statement (SInstruction InstPop)) (Inh_Statement {wp_Inh_Statement= @lhs.wp, wp'_Inh_Statement= @lhs.wp', length_Inh_Statement=0})) 
                              newTrueBranch = SInstruction InstPop : @trueBranch.copy
                              ws            = take (1 + max ((bounded - @lhs.length - 1) `div` (@trueBranch.length+1)) 0) (iterate (\w' -> CAnd (CStack (ITopStackIndex 0)) (wp_Syn_StatementList $ wrap_StatementList (sem_StatementList newTrueBranch) (Inh_StatementList {wp_Inh_StatementList=w', wp'_Inh_StatementList= @lhs.wp', length_Inh_StatementList=0}))) w0)
                          in  foldl1 COr ws
                              
sem Instruction
  | InstSetLocal     lhs.wp = case @lit.copy of
                                (LBool b) -> replace @lhs.wp (Just (CLocal @index, CLit b)) Nothing
                                (LInt  i) -> replace @lhs.wp Nothing (Just (ILocal @index, ILit i))       
  | InstLoadLocal    lhs.wp = let first = replace @lhs.wp (Just (CStack (ITopStackIndex 0), CLocal @index)) (Just (IStack (ITopStackIndex 0), ILocal @index))
                              in  replace first Nothing (Just (ITopStackIndex 0, ITopStackIndex 1))
  | InstStoreLocal   lhs.wp = let first = replace @lhs.wp Nothing (Just (ITopStackIndex 0, ITopStackIndex (-1)))
                              in  CAnd (CGTE (ITopStackIndex 0) (ILit 0)) (replace first (Just (CLocal @index, CStack (ITopStackIndex 0))) (Just (ILocal @index, IStack (ITopStackIndex 0))))
  | InstLoadParam    lhs.wp = let first = replace @lhs.wp (Just (CStack (ITopStackIndex 0), CParamCurr @index)) (Just (IStack (ITopStackIndex 0), IParamCurr @index))
                              in  replace first Nothing (Just (ITopStackIndex 0, ITopStackIndex 1))
  | InstStoreParam   lhs.wp = let first = replace @lhs.wp Nothing (Just (ITopStackIndex 0, ITopStackIndex (-1)))
                              in  CAnd (CGTE (ITopStackIndex 0) (ILit 0)) (replace first (Just (CParamCurr @index, CStack (ITopStackIndex 0))) (Just (IParamCurr @index, IStack (ITopStackIndex 0))))                   
  | InstPushLiteral  lhs.wp = let first = case @lit.copy of
                                           (LBool b) -> replace @lhs.wp (Just (CStack (ITopStackIndex 0), CLit b)) Nothing 
                                           (LInt  i) -> replace @lhs.wp Nothing (Just (IStack (ITopStackIndex 0), ILit i)) 
                              in  replace first Nothing (Just (ITopStackIndex 0, ITopStackIndex 1))
  | InstPop          lhs.wp = CAnd (CGTE (ITopStackIndex 0) (ILit 0)) (replace @lhs.wp Nothing (Just (ITopStackIndex 0, ITopStackIndex (-1))))
  | InstAdd          lhs.wp = binaryOpI @lhs.wp IAdd   
  | InstMin          lhs.wp = binaryOpI @lhs.wp ISub
  | InstMul          lhs.wp = binaryOpI @lhs.wp IMul 
  | InstLT           lhs.wp = binaryOpB @lhs.wp CLT  
  | InstLTE          lhs.wp = binaryOpB @lhs.wp CLTE 
  | InstGT           lhs.wp = binaryOpB @lhs.wp CGT
  | InstGTE          lhs.wp = binaryOpB @lhs.wp CGTE 
  | InstEQ           lhs.wp = binaryOpB @lhs.wp CEQ   
  | InstEquiv        lhs.wp = let first = replace @lhs.wp Nothing (Just (ITopStackIndex 0, ITopStackIndex (-1)))
                              in  CAnd (CGTE (ITopStackIndex 0) (ILit 1)) (replace first (Just (CStack (ITopStackIndex (-1)), CEquiv (CStack (ITopStackIndex (-1))) (CStack (ITopStackIndex 0)))) Nothing)
  | Instreturn       lhs.wp = let first = replace @lhs.wp' Nothing (Just (ITopStackIndex 0, ITopStackIndex (-1)))
                              in  CAnd (CGTE (ITopStackIndex 0) (ILit 0)) (replace first (Just (CReturnValue, CStack (ITopStackIndex 0))) (Just (IReturnValue, IStack (ITopStackIndex 0))))                     

sem Instruction
  | *  lhs.length = 1
                              
sem StatementList
  | Cons   tl.wp     = @lhs.wp
             .wp'    = @lhs.wp'
             .length = @lhs.length + @hd.length
           hd.wp     = @tl.wp  
             .wp'    = @tl.wp'
             .length = @lhs.length + @tl.length             
           lhs.wp    = @hd.wp
              .wp'   = @hd.wp'
              
{
replaceParamWithOld :: Integer -> Cond -> Cond
replaceParamWithOld 0 c = c
replaceParamWithOld n c = replaceParamWithOld (n-1) (replace c (Just (CParamCurr (n-1), CParamOld (n-1))) (Just (IParamCurr (n-1), IParamOld (n-1))))

replace :: Cond -> Maybe (Cond, Cond) -> Maybe (IExpr, IExpr) -> Cond
replace c toReplaceWithC toReplaceWithI = copy_Syn_Cond $ wrap_Cond (sem_Cond c) (Inh_Cond {toReplaceWithC_Inh_Cond=toReplaceWithC, toReplaceWithI_Inh_Cond=toReplaceWithI})

binaryOpI :: Cond -> (IExpr -> IExpr -> IExpr) -> Cond
binaryOpI c op = let first = replace c Nothing (Just (ITopStackIndex 0, ITopStackIndex (-1)))
                 in  CAnd (CGTE (ITopStackIndex 0) (ILit 1)) (replace first Nothing (Just (IStack (ITopStackIndex (-1)), op (IStack (ITopStackIndex (-1))) (IStack (ITopStackIndex 0)))))

binaryOpB :: Cond -> (IExpr -> IExpr -> Cond) -> Cond                 
binaryOpB c op = let first = replace c Nothing (Just (ITopStackIndex 0, ITopStackIndex (-1)))
                 in  CAnd (CGTE (ITopStackIndex 0) (ILit 1)) (replace first (Just (CStack (ITopStackIndex (-1)), op (IStack (ITopStackIndex (-1))) (IStack (ITopStackIndex 0)))) Nothing)
}